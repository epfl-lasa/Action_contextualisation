# Import task_plan and evaluation_plan from 'param_server'
# from param_server import task_plan, evaluation_plan

# Sample import for action functions and checking functions libraries
from .action_functions import *
from .checking_functions import *

from copy import deepcopy

def robot_execution(task_plan, evaluation_plan):
    """Executes the task_plan and performs corresponding checks

    Returns:
        evaluation_log: List of tuples, where each tuple is of form: (action_number, tuple(check_results))
    """
    evaluation_log = []

    for action_number, action_name, action_args in task_plan:
        if action_name == 'approach':
            if is_tuple(action_args):
                result = approach(*action_args)
            else:
                result = approach(action_args)
        elif action_name == 'pick':
            result = pick(*action_args)
        elif action_name == 'place':
            result = place(*action_args)
        elif action_name == 'drop':
            if is_tuple(action_args):
                result = drop(*action_args)
            else:
                result = drop(action_args)
        elif action_name == 'throw':
            if is_tuple(action_args):
                result = throw(*action_args)
            else:
                result = throw(action_args)

        # Check the action using evaluation_plan
        check_function_list = evaluation_plan[int(action_number) - 1][1]
        expected_outputs = evaluation_plan[int(action_number) - 1][2]
        check_results = []
        score = 0

        for check_function, check_args in check_function_list.items():
            if check_function == 'can_grasp':
                if is_tuple(check_args):
                    check_result = can_grasp(*check_args)
                else:
                    check_result = can_grasp(check_args)
            elif check_function == 'holding':
                check_result = holding()
            elif check_function == 'at_location':
                check_result = at_location(*check_args)
            elif check_function == 'collision_free':
                check_result = collision_free()
            elif check_function == 'timeout':
                check_result = timeout()
            elif check_function == 'check_motion_health':
                check_result = check_motion_health()

            # Allocating relevancy score
            score = get_score()

            check_results.append(check_result)

        # Append the action number and check results to the evaluation log
        evaluation_log.append((action_number, tuple(check_results), score))

        # Check if the check results match the expected outputs
        if tuple(check_results) != tuple(expected_outputs):
            return evaluation_log

    return evaluation_log


def performance_logger(evaluation_log, evaluation_plan):
    """Generates a more comprehensive report of the robot's task execution

    Args:
        evaluation_log (List[Tuple[str, Tuple[bool], float]]): The log generated by robot_execution()

    Returns:
        List[Tuple[int, bool, float, Tuple[str, Tuple[str]], str]]: Detailed description of which action failed, and why
    """
    history_log = []

    for action_number, check_outputs, score  in evaluation_log:
        print("action_number")
        print(action_number)
        print("check_outputs")
        print(check_outputs)
        print("score")
        print(score)
        # Initialize variables to track success and failed checks
        action_successful = True
        failed_checks = []

        # Compare the check function outputs with the expected outputs
        _, functions_and_arguments, expected_output = evaluation_plan[int(action_number)]
        print("expected_output")
        print(expected_output)

        for output_index in range(len(check_outputs)):
            try:
                if check_outputs[output_index] != expected_output[output_index]:
                    action_successful = False
                    function_name = list(functions_and_arguments.keys())[output_index]
                    arguments = functions_and_arguments[function_name]
                    # (function_name, arguments) = functions_and_arguments[output_index]
                    failed_checks.append((function_name, arguments, check_outputs[output_index], expected_output[output_index]))
            except:
                breakpoint()

        # Determine the success phrase
        if action_successful:
            success_phrase = "Action was successful."
        else:
            failure_reasons = ""
            for failure_point_index in range(len(failed_checks)):
                func = failed_checks[failure_point_index][0]
                args = failed_checks[failure_point_index][1]
                observed = failed_checks[failure_point_index][2]
                expected = failed_checks[failure_point_index][3]

                if func == 'can_grasp':
                    current_reason = f"{func}({args}) Observed = {observed} Expected = {expected} |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'holding':
                    current_reason = f"{func}({args}) Observed = {observed} Expected = {expected} |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'at_location':
                    current_reason = f"{func}({args}) Observed = {observed} Expected = {expected} |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'collision_free':
                    current_reason = f"{func}() Collision encountered with {observed} |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'timeout':
                    current_reason = f"{func}() Action takes too long |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'check_motion_health':
                    current_reason = f"{func}() Unsafe motion for robot |"
                    failure_reasons = failure_reasons + current_reason
                elif func == 'can_reach':
                    current_reason = f"{func}({args}) Robot is unable to reach {args[0]} |"
                    failure_reasons = failure_reasons + current_reason


            success_phrase = f"Action failed due to: {failure_reasons}."

        # Add to the history log
        history_log.append((action_number, action_successful, score, failed_checks, success_phrase))

    return history_log


def execution_failure(history_log):
    """Checks the history_log to check for success of task plan

    Args:
        history_log (_type_): A detailed description of robot's execution

    Returns:
        bool: Whether the task plan was successful or not
    """
    if history_log[-1][1]:
        return True
    else:
        return False

def explored_parameter_space(task_plan, history_log, parameter_history=None):
    """Systematically stores the actions and their parameters both during successful and failed attempts

    Args:
        history_log (_type_): A detailed description of robot's execution
        parameter_history (_type_, optional): The dictionary that stores the parameters. Defaults to None.

    Returns:
        parameter_history: Updates the paramter dictionary
    """
    if parameter_history is None:
        parameter_history = {'success': {}, 'failure': {}}

    for action_number, success, score, failed_checks, _ in history_log:
        if not success:
            action_name, action_args = task_plan[int(action_number)][1], task_plan[int(action_number)][2]
            object_label = action_args[0]

            if action_name not in parameter_history['failure'].keys():
                parameter_history['failure'][action_name] = {}

            if object_label not in parameter_history['failure'][action_name].keys():
                parameter_history['failure'][action_name][object_label] = []

            if (action_args[1:], score) in parameter_history['failure'][action_name][object_label]:
                pass # Avoiding repeated entries
            else:
                parameter_history['failure'][action_name][object_label].append((action_args[1:], score))


        elif success:
            action_name, action_args = task_plan[int(action_number)][1], task_plan[int(action_number)][2]
            object_label = action_args[0]

            if action_name not in parameter_history['success'].keys():
                parameter_history['success'][action_name] = {}

            if object_label not in parameter_history['success'][action_name].keys():
                parameter_history['success'][action_name][object_label] = []

            if (action_args[1:], score) in parameter_history['success'][action_name][object_label]:
                pass # Avoiding repeated entries
            else:
                parameter_history['success'][action_name][object_label].append((action_args[1:], score))

    return parameter_history


def explored_domain(task_plan, evaluation_plan, success_state: bool, domain_history=None):
    """Saves the task_plan and evaluation_plan with positive or negative labels

    Args:
        success_state (bool): Whether the plan was succesful or not
        domain_history (_type_, optional): A dictionary that saves the succesful and failed instances. Key is "success" or "failure" whereas value is a list of (task_plan, evaluation_plan) tuples. Defaults to None.

    Returns:
        domain_history: Updates and returns the domain_history dictionary
    """
    if domain_history is None:
        domain_history = {'success': [], 'failure': []}

    if success_state:
        domain_history['success'].append((task_plan, evaluation_plan))
    else:
        domain_history['failure'].append((task_plan, evaluation_plan))

    return domain_history


def is_tuple(item):
    """
    Check if the input is a single-element tuple.

    Args:
    item: The item to check.

    Returns:
    bool: True if item is a single-element tuple, False otherwise.
    """
    return isinstance(item, tuple)